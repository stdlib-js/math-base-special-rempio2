{"version":3,"file":"index.mjs","sources":["../lib/kernel_rempio2.js","../lib/rempio2_medium.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The following copyright and license were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/k_rem_pio2.c}. The implementation follows the original, but has been modified for JavaScript.\n*\n* ```text\n* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n*\n* Developed at SunPro, a Sun Microsystems, Inc. business.\n* Permission to use, copy, modify, and distribute this\n* software is freely granted, provided that this notice\n* is preserved.\n* ```\n*/\n\n/* eslint-disable array-element-newline */\n\n'use strict';\n\n// MODULES //\n\nimport floor from '@stdlib/math-base-special-floor';\nimport ldexp from '@stdlib/math-base-special-ldexp';\nimport zeros from '@stdlib/array-base-zeros';\n\n\n// VARIABLES //\n\n/*\n* Table of constants for `2/π` (`396` hex digits, `476` decimal).\n*\n* Integer array which contains the (`24*i`)-th to (`24*i+23`)-th bit of `2/π` after binary point. The corresponding floating value is\n*\n* ```tex\n* \\operatorname{ipio2}[i] \\cdot 2^{-24(i+1)}\n* ```\n*\n* This table must have at least `(e0-3)/24 + jk` terms. For quad precision (`e0 <= 16360`, `jk = 6`), this is `686`.\n*/\nvar IPIO2 = [\n\t0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62,\n\t0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7, 0x246E3A,\n\t0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129,\n\t0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C, 0x7026B4, 0x5F7E41,\n\t0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8,\n\t0x97FFDE, 0x05980F, 0xEF2F11, 0x8B5A0A, 0x6D1F6D, 0x367ECF,\n\t0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5,\n\t0xF17B3D, 0x0739F7, 0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08,\n\t0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3,\n\t0x91615E, 0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880,\n\t0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B\n];\n\n// Double precision array, obtained by cutting `π/2` into `24` bits chunks...\nvar PIO2 = [\n\t1.57079625129699707031e+00, // 0x3FF921FB, 0x40000000\n\t7.54978941586159635335e-08, // 0x3E74442D, 0x00000000\n\t5.39030252995776476554e-15, // 0x3CF84698, 0x80000000\n\t3.28200341580791294123e-22, // 0x3B78CC51, 0x60000000\n\t1.27065575308067607349e-29, // 0x39F01B83, 0x80000000\n\t1.22933308981111328932e-36, // 0x387A2520, 0x40000000\n\t2.73370053816464559624e-44, // 0x36E38222, 0x80000000\n\t2.16741683877804819444e-51  // 0x3569F31D, 0x00000000\n];\nvar TWO24 = 1.67772160000000000000e+07;  // 0x41700000, 0x00000000\nvar TWON24 = 5.96046447753906250000e-08; // 0x3E700000, 0x00000000\n\n// Arrays for storing temporary values (note that, in C, this is not thread safe):\nvar F = zeros( 20 );\nvar Q = zeros( 20 );\nvar FQ = zeros( 20 );\nvar IQ = zeros( 20 );\n\n\n// FUNCTIONS //\n\n/**\n* Performs the computation for `kernelRempio2()`.\n*\n* @private\n* @param {PositiveNumber} x - input value\n* @param {(Array|TypedArray|Object)} y - output object for storing double precision numbers\n* @param {integer} jz - number of terms of `ipio2[]` used\n* @param {Array<integer>} q - array with integral values, representing the 24-bits chunk of the product of `x` and `2/π`\n* @param {integer} q0 - the corresponding exponent of `q[0]` (the exponent for `q[i]` would be `q0-24*i`)\n* @param {integer} jk - `jk+1` is the initial number of terms of `IPIO2[]` needed in the computation\n* @param {integer} jv - index for pointing to the suitable `ipio2[]` for the computation\n* @param {integer} jx - `nx - 1`\n* @param {Array<number>} f - `IPIO2[]` in floating point\n* @returns {number} last three binary digits of `N`\n*/\nfunction compute( x, y, jz, q, q0, jk, jv, jx, f ) {\n\tvar carry;\n\tvar fw;\n\tvar ih;\n\tvar jp;\n\tvar i;\n\tvar k;\n\tvar n;\n\tvar j;\n\tvar z;\n\n\t// `jp+1` is the number of terms in `PIO2[]` needed:\n\tjp = jk;\n\n\t// Distill `q[]` into `IQ[]` in reverse order...\n\tz = q[ jz ];\n\tj = jz;\n\tfor ( i = 0; j > 0; i++ ) {\n\t\tfw = ( TWON24 * z )|0;\n\t\tIQ[ i ] = ( z - (TWO24*fw) )|0;\n\t\tz = q[ j-1 ] + fw;\n\t\tj -= 1;\n\t}\n\t// Compute `n`...\n\tz = ldexp( z, q0 );\n\tz -= 8.0 * floor( z*0.125 ); // Trim off integer >= 8\n\tn = z|0;\n\tz -= n;\n\tih = 0;\n\tif ( q0 > 0 ) {\n\t\t// Need `IQ[jz-1]` to determine `n`...\n\t\ti = ( IQ[ jz-1 ] >> (24-q0) );\n\t\tn += i;\n\t\tIQ[ jz-1 ] -= ( i << (24-q0) );\n\t\tih = ( IQ[ jz-1 ] >> (23-q0) );\n\t}\n\telse if ( q0 === 0 ) {\n\t\tih = ( IQ[ jz-1 ] >> 23 );\n\t}\n\telse if ( z >= 0.5 ) {\n\t\tih = 2;\n\t}\n\t// Case: q > 0.5\n\tif ( ih > 0 ) {\n\t\tn += 1;\n\t\tcarry = 0;\n\n\t\t// Compute `1-q`:\n\t\tfor ( i = 0; i < jz; i++ ) {\n\t\t\tj = IQ[ i ];\n\t\t\tif ( carry === 0 ) {\n\t\t\t\tif ( j !== 0 ) {\n\t\t\t\t\tcarry = 1;\n\t\t\t\t\tIQ[ i ] = 0x1000000 - j;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tIQ[ i ] = 0xffffff - j;\n\t\t\t}\n\t\t}\n\t\tif ( q0 > 0 ) {\n\t\t\t// Rare case: chance is 1 in 12...\n\t\t\tswitch ( q0 ) { // eslint-disable-line default-case\n\t\t\tcase 1:\n\t\t\t\tIQ[ jz-1 ] &= 0x7fffff;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tIQ[ jz-1 ] &= 0x3fffff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( ih === 2 ) {\n\t\t\tz = 1.0 - z;\n\t\t\tif ( carry !== 0 ) {\n\t\t\t\tz -= ldexp( 1.0, q0 );\n\t\t\t}\n\t\t}\n\t}\n\t// Check if re-computation is needed...\n\tif ( z === 0.0 ) {\n\t\tj = 0;\n\t\tfor ( i = jz-1; i >= jk; i-- ) {\n\t\t\tj |= IQ[ i ];\n\t\t}\n\t\tif ( j === 0 ) {\n\t\t\t// Need re-computation...\n\t\t\tfor ( k = 1; IQ[ jk-k ] === 0; k++ ) {\n\t\t\t\t// `k` is the number of terms needed...\n\t\t\t}\n\t\t\tfor ( i = jz+1; i <= jz+k; i++ ) {\n\t\t\t\t// Add `q[jz+1]` to `q[jz+k]`...\n\t\t\t\tf[ jx+i ] = IPIO2[ jv+i ];\n\t\t\t\tfw = 0.0;\n\t\t\t\tfor ( j = 0; j <= jx; j++ ) {\n\t\t\t\t\tfw += x[ j ] * f[ jx + (i-j) ];\n\t\t\t\t}\n\t\t\t\tq[ i ] = fw;\n\t\t\t}\n\t\t\tjz += k;\n\t\t\treturn compute( x, y, jz, q, q0, jk, jv, jx, f );\n\t\t}\n\t\t// Chop off zero terms...\n\t\tjz -= 1;\n\t\tq0 -= 24;\n\t\twhile ( IQ[ jz ] === 0 ) {\n\t\t\tjz -= 1;\n\t\t\tq0 -= 24;\n\t\t}\n\t} else {\n\t\t// Break `z` into 24-bit if necessary...\n\t\tz = ldexp( z, -q0 );\n\t\tif ( z >= TWO24 ) {\n\t\t\tfw = (TWON24*z)|0;\n\t\t\tIQ[ jz ] = ( z - (TWO24*fw) )|0;\n\t\t\tjz += 1;\n\t\t\tq0 += 24;\n\t\t\tIQ[ jz ] = fw;\n\t\t} else {\n\t\t\tIQ[ jz ] = z|0;\n\t\t}\n\t}\n\t// Convert integer \"bit\" chunk to floating-point value...\n\tfw = ldexp( 1.0, q0 );\n\tfor ( i = jz; i >= 0; i-- ) {\n\t\tq[ i ] = fw * IQ[i];\n\t\tfw *= TWON24;\n\t}\n\t// Compute `PIO2[0,...,jp]*q[jz,...,0]`...\n\tfor ( i = jz; i >= 0; i-- ) {\n\t\tfw = 0.0;\n\t\tfor ( k = 0; k <= jp && k <= jz-i; k++ ) {\n\t\t\tfw += PIO2[ k ] * q[ i+k ];\n\t\t}\n\t\tFQ[ jz-i ] = fw;\n\t}\n\t// Compress `FQ[]` into `y[]`...\n\tfw = 0.0;\n\tfor ( i = jz; i >= 0; i-- ) {\n\t\tfw += FQ[ i ];\n\t}\n\tif ( ih === 0 ) {\n\t\ty[ 0 ] = fw;\n\t} else {\n\t\ty[ 0 ] = -fw;\n\t}\n\tfw = FQ[ 0 ] - fw;\n\tfor ( i = 1; i <= jz; i++ ) {\n\t\tfw += FQ[i];\n\t}\n\tif ( ih === 0 ) {\n\t\ty[ 1 ] = fw;\n\t} else {\n\t\ty[ 1 ] = -fw;\n\t}\n\treturn ( n & 7 );\n}\n\n\n// MAIN //\n\n/**\n* Returns the last three binary digits of `N` with `y = x - Nπ/2` so that `|y| < π/2`.\n*\n* ## Method\n*\n* -   The method is to compute the integer (mod 8) and fraction parts of (2/π) * x without doing the full multiplication. In general, we skip the part of the product that are known to be a huge integer (more accurately, = 0 mod 8 ). Thus the number of operations are independent of the exponent of the input.\n*\n* -   (2/π) is represented by an array of 24-bit integers in `ipio2[]`.\n*\n* -   Input parameters:\n*\n*     -   `x[]` The input value (must be positive) is broken into `nx` pieces of 24-bit integers in double precision format. `x[i]` will be the i-th 24 bit of x. The scaled exponent of `x[0]` is given in input parameter `e0` (i.e., `x[0]*2^e0` match x's up to 24 bits).\n*\n*         Example of breaking a double positive `z` into `x[0]+x[1]+x[2]`:\n*\n*         ```tex\n*         e0 = \\mathrm{ilogb}(z) - 23\n*         z = \\mathrm{scalbn}(z, -e0)\n*         ```\n*\n*         for `i = 0,1,2`\n*\n*         ```tex\n*         x[i] = \\lfloor z \\rfloor\n*         z = (z - x[i]) \\times 2^{24}\n*         ```\n*\n*     -   `y[]` output result in an array of double precision numbers.\n*\n*         The dimension of `y[]` is:\n*         24-bit precision     1\n*         53-bit precision     2\n*         64-bit precision     2\n*         113-bit precision    3\n*\n*         The actual value is the sum of them. Thus, for 113-bit precision, one may have to do something like:\n*\n*         ```tex\n*         \\mathrm{long\\ double} \\: t, w, r_{\\text{head}}, r_{\\text{tail}}; \\\\\n*         t &= (\\mathrm{long\\ double}) y[2] + (\\mathrm{long\\ double}) y[1]; \\\\\n*         w &= (\\mathrm{long\\ double}) y[0]; \\\\\n*         r_{\\text{head}} &= t + w; \\\\\n*         r_{\\text{tail}} &= w - (r_{\\text{head}} - t);\n*         ```\n*\n*     -   `e0` The exponent of `x[0]`. Must be <= 16360 or you need to expand the `ipio2` table.\n*\n*     -   `nx` dimension of `x[]`\n*\n*     -   `prec` an integer indicating the precision:\n*         0 24 bits (single)\n*         1 53 bits (double)\n*         2 64 bits (extended)\n*         3 113 bits (quad)\n*\n* -   External function:\n*\n*     -   double `scalbn()`, `floor()`;\n*\n* -   Here is the description of some local variables:\n*\n*     -   `jk` `jk+1` is the initial number of terms of `ipio2[]` needed in the computation. The minimum and recommended value for `jk` is 3,4,4,6 for single, double, extended, and quad. `jk+1` must be 2 larger than you might expect so that our recomputation test works. (Up to 24 bits in the integer part (the 24 bits of it that we compute) and 23 bits in the fraction part may be lost to cancellation before we recompute.)\n*\n*     -   `jz` local integer variable indicating the number of terms of `ipio2[]` used.\n*\n*     -   `jx` `nx - 1`\n*\n*     -   `jv` index for pointing to the suitable `ipio2[]` for the computation. In general, we want\n*\n*         ```tex\n*         \\frac{{2^{e0} \\cdot x[0] \\cdot \\mathrm{ipio2}[jv-1] \\cdot 2^{-24jv}}}{{8}}\n*         ```\n*\n*         to be an integer. Thus\n*\n*         ```tex\n*         e0 - 3 - 24 \\cdot jv \\geq 0 \\quad \\text{or} \\quad \\frac{{e0 - 3}}{{24}} \\geq jv\n*         ```\n*\n*         Hence\n*\n*         ```tex\n*         jv = \\max(0, \\frac{{e0 - 3}}{{24}})\n*         ```\n*\n*     -   `jp` `jp+1` is the number of terms in `PIo2[]` needed, `jp = jk`.\n*\n*     -   `q[]` double array with integral value, representing the 24-bits chunk of the product of `x` and `2/π`.\n*\n*     -   `q0` the corresponding exponent of `q[0]`. Note that the exponent for `q[i]` would be `q0-24*i`.\n*\n*     -   `PIo2[]` double precision array, obtained by cutting `π/2` into 24 bits chunks.\n*\n*     -   `f[]` `ipso2[]` in floating point\n*\n*     -   `iq[]` integer array by breaking up `q[]` in 24-bits chunk.\n*\n*     -   `fq[]` final product of `x*(2/π)` in `fq[0],..,fq[jk]`\n*\n*     -   `ih` integer. If >0 it indicates `q[]` is >= 0.5, hence it also indicates the _sign_ of the result.\n*\n* -   Constants:\n*\n*     -   The hexadecimal values are the intended ones for the following constants. The decimal values may be used, provided that the compiler will convert from decimal to binary accurately enough to produce the hexadecimal values shown.\n*\n* @private\n* @param {PositiveNumber} x - input value\n* @param {(Array|TypedArray|Object)} y - remainder elements\n* @param {PositiveInteger} e0 - the exponent of `x[0]` (must be <= 16360)\n* @param {PositiveInteger} nx - dimension of `x[]`\n* @returns {number} last three binary digits of `N`\n*/\nfunction kernelRempio2( x, y, e0, nx ) {\n\tvar fw;\n\tvar jk;\n\tvar jv;\n\tvar jx;\n\tvar jz;\n\tvar q0;\n\tvar i;\n\tvar j;\n\tvar m;\n\n\t// Initialize `jk` for double-precision floating-point numbers:\n\tjk = 4;\n\n\t// Determine `jx`, `jv`, `q0` (note that `q0 < 3`):\n\tjx = nx - 1;\n\tjv = ( (e0 - 3) / 24 )|0;\n\tif ( jv < 0 ) {\n\t\tjv = 0;\n\t}\n\tq0 = e0 - (24 * (jv + 1));\n\n\t// Set up `F[0]` to `F[jx+jk]` where `F[jx+jk] = IPIO2[jv+jk]`:\n\tj = jv - jx;\n\tm = jx + jk;\n\tfor ( i = 0; i <= m; i++ ) {\n\t\tif ( j < 0 ) {\n\t\t\tF[ i ] = 0.0;\n\t\t} else {\n\t\t\tF[ i ] = IPIO2[ j ];\n\t\t}\n\t\tj += 1;\n\t}\n\t// Compute `Q[0],Q[1],...,Q[jk]`:\n\tfor ( i = 0; i <= jk; i++ ) {\n\t\tfw = 0.0;\n\t\tfor ( j = 0; j <= jx; j++ ) {\n\t\t\tfw += x[ j ] * F[ jx + (i-j) ];\n\t\t}\n\t\tQ[ i ] = fw;\n\t}\n\tjz = jk;\n\treturn compute( x, y, jz, Q, q0, jk, jv, jx, F );\n}\n\n\n// EXPORTS //\n\nexport default kernelRempio2;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The following copyright and license were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/k_rem_pio2.c}. The implementation follows the original, but has been modified for JavaScript.\n*\n* ```text\n* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n*\n* Developed at SunPro, a Sun Microsystems, Inc. business.\n* Permission to use, copy, modify, and distribute this\n* software is freely granted, provided that this notice\n* is preserved.\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport round from '@stdlib/math-base-special-round';\nimport getHighWord from '@stdlib/number-float64-base-get-high-word';\n\n\n// VARIABLES //\n\n// 53 bits of 2/π:\nvar INVPIO2 = 6.36619772367581382433e-01; // 0x3FE45F30, 0x6DC9C883\n\n// First 33 bits of π/2:\nvar PIO2_1 = 1.57079632673412561417e+00;  // 0x3FF921FB, 0x54400000\n\n// PIO2_1T = π/2 - PIO2_1:\nvar PIO2_1T = 6.07710050650619224932e-11; // 0x3DD0B461, 0x1A626331\n\n// Another 33 bits of π/2:\nvar PIO2_2 = 6.07710050630396597660e-11;  // 0x3DD0B461, 0x1A600000\n\n// PIO2_2T = π/2 - ( PIO2_1 + PIO2_2 ):\nvar PIO2_2T = 2.02226624879595063154e-21; // 0x3BA3198A, 0x2E037073\n\n// Another 33 bits of π/2:\nvar PIO2_3 = 2.02226624871116645580e-21;  // 0x3BA3198A, 0x2E000000\n\n// PIO2_3T = π/2 - ( PIO2_1 + PIO2_2 + PIO2_3 ):\nvar PIO2_3T = 8.47842766036889956997e-32; // 0x397B839A, 0x252049C1\n\n// Exponent mask (2047 => 0x7ff):\nvar EXPONENT_MASK = 0x7ff|0; // asm type annotation\n\n\n// MAIN //\n\n/**\n* Computes `x - nπ/2 = r` for medium-sized inputs.\n*\n* @private\n* @param {number} x - input value\n* @param {uint32} ix - high word of `x`\n* @param {(Array|TypedArray|Object)} y - remainder elements\n* @returns {integer} factor of `π/2`\n*/\nfunction rempio2Medium( x, ix, y ) {\n\tvar high;\n\tvar n;\n\tvar t;\n\tvar r;\n\tvar w;\n\tvar i;\n\tvar j;\n\n\tn = round( x * INVPIO2 );\n\tr = x - ( n * PIO2_1 );\n\tw = n * PIO2_1T;\n\n\t// First rounding (good to 85 bits)...\n\tj = (ix >> 20)|0; // asm type annotation\n\ty[ 0 ] = r - w;\n\thigh = getHighWord( y[0] );\n\ti = j - ( (high >> 20) & EXPONENT_MASK );\n\n\t// Check if a second iteration is needed (good to 118 bits)...\n\tif ( i > 16 ) {\n\t\tt = r;\n\t\tw = n * PIO2_2;\n\t\tr = t - w;\n\t\tw = (n * PIO2_2T) - ((t-r) - w);\n\t\ty[ 0 ] = r - w;\n\t\thigh = getHighWord( y[0] );\n\t\ti = j - ( (high >> 20) & EXPONENT_MASK );\n\n\t\t// Check if a third iteration is needed (151 bits accumulated)...\n\t\tif ( i > 49 ) {\n\t\t\tt = r;\n\t\t\tw = n * PIO2_3;\n\t\t\tr = t - w;\n\t\t\tw = (n * PIO2_3T) - ((t-r) - w);\n\t\t\ty[ 0 ] = r - w;\n\t\t}\n\t}\n\ty[ 1 ] = (r - y[0]) - w;\n\treturn n;\n}\n\n\n// EXPORTS //\n\nexport default rempio2Medium;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The following copyright and license were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/e_rem_pio2.c}. The implementation follows the original, but has been modified for JavaScript.\n*\n* ```text\n* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n*\n* Developed at SunPro, a Sun Microsystems, Inc. business.\n* Permission to use, copy, modify, and distribute this\n* software is freely granted, provided that this notice\n* is preserved.\n*\n* Optimized by Bruce D. Evans.\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport ABS_MASK from '@stdlib/constants-float64-high-word-abs-mask';\nimport EXPONENT_MASK from '@stdlib/constants-float64-high-word-exponent-mask';\nimport SIGNIFICAND_MASK from '@stdlib/constants-float64-high-word-significand-mask';\nimport getHighWord from '@stdlib/number-float64-base-get-high-word';\nimport getLowWord from '@stdlib/number-float64-base-get-low-word';\nimport fromWords from '@stdlib/number-float64-base-from-words';\nimport rempio2Kernel from './kernel_rempio2.js';\nimport rempio2Medium from './rempio2_medium.js';\n\n\n// VARIABLES //\n\nvar ZERO = 0.00000000000000000000e+00;    // 0x00000000, 0x00000000\nvar TWO24 = 1.67772160000000000000e+07;   // 0x41700000, 0x00000000\n\n// 33 bits of π/2:\nvar PIO2_1 = 1.57079632673412561417e+00;  // 0x3FF921FB, 0x54400000\n\n// PIO2_1T = π/2 - PIO2_1:\nvar PIO2_1T = 6.07710050650619224932e-11; // 0x3DD0B461, 0x1A626331\nvar TWO_PIO2_1T = 2.0 * PIO2_1T;\nvar THREE_PIO2_1T = 3.0 * PIO2_1T;\nvar FOUR_PIO2_1T = 4.0 * PIO2_1T;\n\n// High word significand for π and π/2: 0x921fb = 598523 => 00000000000010010010000111111011\nvar PI_HIGH_WORD_SIGNIFICAND = 0x921fb|0; // asm type annotation\n\n// High word for π/4: 0x3fe921fb = 1072243195 => 00111111111010010010000111111011\nvar PIO4_HIGH_WORD = 0x3fe921fb|0; // asm type annotation\n\n// High word for 3π/4: 0x4002d97c = 1073928572 => 01000000000000101101100101111100\nvar THREE_PIO4_HIGH_WORD = 0x4002d97c|0; // asm type annotation\n\n// High word for 5π/4: 0x400f6a7a = 1074752122 => 01000000000011110110101001111010\nvar FIVE_PIO4_HIGH_WORD = 0x400f6a7a|0; // asm type annotation\n\n// High word for 6π/4: 0x4012d97c = 1074977148 => 01000000000100101101100101111100\nvar THREE_PIO2_HIGH_WORD = 0x4012d97c|0; // asm type annotation\n\n// High word for 7π/4: 0x4015fdbc = 1075183036 => 01000000000101011111110110111100\nvar SEVEN_PIO4_HIGH_WORD = 0x4015fdbc|0; // asm type annotation\n\n// High word for 8π/4: 0x401921fb = 1075388923 => 01000000000110010010000111111011\nvar TWO_PI_HIGH_WORD = 0x401921fb|0; // asm type annotation\n\n// High word for 9π/4: 0x401c463b = 1075594811 => 01000000000111000100011000111011\nvar NINE_PIO4_HIGH_WORD = 0x401c463b|0; // asm type annotation\n\n// 2^20*π/2 = 1647099.3291652855 => 0100000100111001001000011111101101010100010001000010110100011000 => high word => 0x413921fb = 1094263291 => 01000001001110010010000111111011\nvar MEDIUM = 0x413921fb|0; // asm type annotation\n\n// Arrays for storing temporary values:\nvar TX = [ 0.0, 0.0, 0.0 ];\nvar TY = [ 0.0, 0.0 ];\n\n\n// MAIN //\n\n/**\n* Computes `x - nπ/2 = r`.\n*\n* ## Notes\n*\n* -   Returns `n` and stores the remainder `r` as two numbers `y[0]` and `y[1]`, such that `y[0]+y[1] = r`.\n*\n* @param {number} x - input value\n* @param {(Array|TypedArray|Object)} y - remainder elements\n* @returns {integer} factor of `π/2`\n*\n* @example\n* var y = [ 0.0, 0.0 ];\n* var n = rempio2( 128.0, y );\n* // returns 81\n*\n* var y1 = y[ 0 ];\n* // returns ~0.765\n*\n* var y2 = y[ 1 ];\n* // returns ~3.618e-17\n*\n* @example\n* var y = [ 0.0, 0.0 ];\n* var n = rempio2( NaN, y );\n* // returns 0\n*\n* var y1 = y[ 0 ];\n* // returns NaN\n*\n* var y2 = y[ 1 ];\n* // returns NaN\n*/\nfunction rempio2( x, y ) {\n\tvar low;\n\tvar e0;\n\tvar hx;\n\tvar ix;\n\tvar nx;\n\tvar i;\n\tvar n;\n\tvar z;\n\n\thx = getHighWord( x );\n\tix = (hx & ABS_MASK)|0; // asm type annotation\n\n\t// Case: |x| ~<= π/4 (no need for reduction)\n\tif ( ix <= PIO4_HIGH_WORD ) {\n\t\ty[ 0 ] = x;\n\t\ty[ 1 ] = 0.0;\n\t\treturn 0;\n\t}\n\t// Case: |x| ~<= 5π/4\n\tif ( ix <= FIVE_PIO4_HIGH_WORD ) {\n\t\t// Case: |x| ~= π/2 or π\n\t\tif ( (ix & SIGNIFICAND_MASK) === PI_HIGH_WORD_SIGNIFICAND ) {\n\t\t\t// Cancellation => use medium case\n\t\t\treturn rempio2Medium( x, ix, y );\n\t\t}\n\t\t// Case: |x| ~<= 3π/4\n\t\tif ( ix <= THREE_PIO4_HIGH_WORD ) {\n\t\t\tif ( x > 0.0 ) {\n\t\t\t\tz = x - PIO2_1;\n\t\t\t\ty[ 0 ] = z - PIO2_1T;\n\t\t\t\ty[ 1 ] = (z - y[0]) - PIO2_1T;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tz = x + PIO2_1;\n\t\t\ty[ 0 ] = z + PIO2_1T;\n\t\t\ty[ 1 ] = (z - y[0]) + PIO2_1T;\n\t\t\treturn -1;\n\t\t}\n\t\tif ( x > 0.0 ) {\n\t\t\tz = x - ( 2.0*PIO2_1 );\n\t\t\ty[ 0 ] = z - TWO_PIO2_1T;\n\t\t\ty[ 1 ] = (z - y[0]) - TWO_PIO2_1T;\n\t\t\treturn 2;\n\t\t}\n\t\tz = x + ( 2.0*PIO2_1 );\n\t\ty[ 0 ] = z + TWO_PIO2_1T;\n\t\ty[ 1 ] = (z - y[0]) + TWO_PIO2_1T;\n\t\treturn -2;\n\t}\n\t// Case: |x| ~<= 9π/4\n\tif ( ix <= NINE_PIO4_HIGH_WORD ) {\n\t\t// Case: |x| ~<= 7π/4\n\t\tif ( ix <= SEVEN_PIO4_HIGH_WORD ) {\n\t\t\t// Case: |x| ~= 3π/2\n\t\t\tif ( ix === THREE_PIO2_HIGH_WORD ) {\n\t\t\t\treturn rempio2Medium( x, ix, y );\n\t\t\t}\n\t\t\tif ( x > 0.0 ) {\n\t\t\t\tz = x - ( 3.0*PIO2_1 );\n\t\t\t\ty[ 0 ] = z - THREE_PIO2_1T;\n\t\t\t\ty[ 1 ] = (z - y[0]) - THREE_PIO2_1T;\n\t\t\t\treturn 3;\n\t\t\t}\n\t\t\tz = x + ( 3.0*PIO2_1 );\n\t\t\ty[ 0 ] = z + THREE_PIO2_1T;\n\t\t\ty[ 1 ] = (z - y[0]) + THREE_PIO2_1T;\n\t\t\treturn -3;\n\t\t}\n\t\t// Case: |x| ~= 4π/2\n\t\tif ( ix === TWO_PI_HIGH_WORD ) {\n\t\t\treturn rempio2Medium( x, ix, y );\n\t\t}\n\t\tif ( x > 0.0 ) {\n\t\t\tz = x - ( 4.0*PIO2_1 );\n\t\t\ty[ 0 ] = z - FOUR_PIO2_1T;\n\t\t\ty[ 1 ] = (z - y[0]) - FOUR_PIO2_1T;\n\t\t\treturn 4;\n\t\t}\n\t\tz = x + ( 4.0*PIO2_1 );\n\t\ty[ 0 ] = z + FOUR_PIO2_1T;\n\t\ty[ 1 ] = (z - y[0]) + FOUR_PIO2_1T;\n\t\treturn -4;\n\t}\n\t// Case: |x| ~< 2^20*π/2 (medium size)\n\tif ( ix < MEDIUM ) {\n\t\treturn rempio2Medium( x, ix, y );\n\t}\n\t// Case: x is NaN or infinity\n\tif ( ix >= EXPONENT_MASK ) {\n\t\ty[ 0 ] = NaN;\n\t\ty[ 1 ] = NaN;\n\t\treturn 0.0;\n\t}\n\t// Set z = scalbn(|x|, ilogb(x)-23)...\n\tlow = getLowWord( x );\n\te0 = (ix >> 20) - 1046; // `e0 = ilogb(z) - 23` => unbiased exponent minus 23\n\tz = fromWords( ix - ((e0 << 20)|0), low );\n\tfor ( i = 0; i < 2; i++ ) {\n\t\tTX[ i ] = z|0;\n\t\tz = (z - TX[i]) * TWO24;\n\t}\n\tTX[ 2 ] = z;\n\tnx = 3;\n\twhile ( TX[ nx-1 ] === ZERO ) {\n\t\t// Skip zero term...\n\t\tnx -= 1;\n\t}\n\tn = rempio2Kernel( TX, TY, e0, nx, 1 );\n\tif ( x < 0.0 ) {\n\t\ty[ 0 ] = -TY[ 0 ];\n\t\ty[ 1 ] = -TY[ 1 ];\n\t\treturn -n;\n\t}\n\ty[ 0 ] = TY[ 0 ];\n\ty[ 1 ] = TY[ 1 ];\n\treturn n;\n}\n\n\n// EXPORTS //\n\nexport default rempio2;\n"],"names":["IPIO2","PIO2","TWO24","TWON24","F","zeros","Q","FQ","IQ","compute","x","y","jz","q","q0","jk","jv","jx","f","carry","fw","ih","jp","i","k","n","j","z","ldexp","floor","kernelRempio2","e0","nx","m","INVPIO2","PIO2_1","PIO2_1T","PIO2_2","PIO2_2T","PIO2_3","PIO2_3T","EXPONENT_MASK","rempio2Medium","ix","t","r","w","round","getHighWord","TWO_PIO2_1T","THREE_PIO2_1T","FOUR_PIO2_1T","TX","TY","rempio2","low","ABS_MASK","SIGNIFICAND_MASK","NaN","getLowWord","fromWords","rempio2Kernel"],"mappings":"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"}